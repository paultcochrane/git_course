\documentclass{git_course}

\begin{document}

\author{Paul Cochrane}
\title[Version control with Git]
        {Version control with Git}
\date{\today}

\maketitle

\begin{frame}
\begin{multicols}{2}
\begin{spacing}{0.8}
\tableofcontents
\end{spacing}
\end{multicols}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{About the course}

\begin{frame}
\frametitle{Course Goals}

At the end of this course you should:

\begin{itemize}
    \item Feel comfortable using Git
    \item Know where to get further help, if necessary
    \item Be able to use Git on private projects
    \item Be able to collaborate with others using remote repositories
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Course Outline}
\begin{itemize}
    \item Introduction to Git and version control systems
    \item Installing Git
    \item Creating a first repository
    \item Getting help
    \item Tracking/staging/committing
    \item Configuring repositories
    \item General workflow
    \item Getting repository information
    \item Working with others
    \item Using branches and tags
    \item Rewriting history
    \item Contributing to Open Source projects
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Course Information}
\begin{itemize}
    \item Feedback most welcome
    \item Slides and notes are available on the GitHub docs site for the
        course:\\
        {\footnotesize \url{https://paultcochrane.github.io/version\_control\_course/}}
    \item You can submit pull requests, file issues, on GitHub:\\
        {\footnotesize \url{https://github.com/paultcochrane/version\_control\_course/}}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{About Me}
\begin{itemize}
    \item Physicist from New Zealand
    \item Have been involved in scientific computing and development of
        scientific software in Australia and Germany
    \item Led the scientific computing group at the Regional Computing
        Centre for Lower Saxony
    \item Currently a software developer for a startup in Bremen
        specialising in delivery of satellite-based information to users in
        polar regions
    \item Active in the Perl language community
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Version control systems and Git history}

\begin{frame}
\frametitle{What are Version Control Systems?}
\begin{itemize}
    \item A way to track changes to groups of files
    \item Most often used in software projects
    \item Most often used to track changes to text files (but not
        exclusively)
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{What are Version Control Systems?}
\begin{itemize}
    \item Akin to a time machine: one can return to previous states of a
        project
\end{itemize}
\begin{figure}
    \centerline{%
    \includegraphics[width=0.7\textwidth]{images/The_Delorian_William_Warby_flickr.pdf}}
        \caption{\tiny \emph{The Delorian}, by William Warby, Flickr:
    \url{https://www.flickr.com/photos/wwarby/9641216546/in/photostream/}}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{What are Version Control Systems?}
\begin{itemize}
    \item Like a safety net: accidental file deletion isn't a catastrophe
        % -> image of a safety net
    \item Saved states are like anchor points in like rock climbing:
        one can fall back a small distance without losing everything
        % -> image of anchor point/rock climber
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Why Use a Version Control System?}

Does this look familiar?

\begin{lstlisting}
file.1      file.20090803  file.keep
file.2      file.alt       file.old
file.old.2  file.fixed     file.new
\end{lstlisting}

This is better than nothing, however \ldots
\begin{itemize}
    \item what happened between the different versions?
    \item which file is actually the most current?
    \item what if \ttt{file.old} is the \emph{newest} file?
    \item can the differences between files tell us anything?
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Why Use a Version Control System?}
\begin{itemize}
    \item Useful in detecting when bugs were introduced or fixed
    \item Used to save known states of a group of files and hence versions
        (releases) of a software project
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Version Control Systems}
\begin{itemize}
    \item Local
        % -> image/diagram of local system
    \begin{itemize}
        \item e.g. RCS
    \end{itemize}
    \item Centralised
    \begin{center}
        \resizebox{!}{0.7\textheight}{
            \input{figures/CentralRepo_tikz.tex}
        }
    \end{center}
        % -> image/diagram of centralised system
    \begin{itemize}
        \item e.g. Subversion, CVS
    \end{itemize}
    \item Distributed
        % -> image/diagram of distributed system
    \begin{itemize}
        \item e.g. Git, Mercurial
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Git History}
\begin{itemize}
    \item BitKeeper
    \item License problems
    \item Linux wrote his own system
    \item Open source
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Installing Git}

\begin{frame}
\frametitle{Installing Git (CLI options)}
\begin{itemize}
    \item Windows
    \item MacOS
    \item Linux/Unix
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Installing Git (GUI options)}
\begin{itemize}
    \item SourceTree
    \item TortoiseGit
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Use the Command Line}
\begin{itemize}
    \item With the command line one can get futher and do more; the
        learning curve is steeper, but it's worth it.
    \item Hence, we will focus on the command line interface (CLI) from now
        on.
\end{itemize}
    \blockquote[Hunt and Thomas, \emph{The Pragmatic Programmer}]
    {Gain familiarity with the shell, and you'll find your productivity soaring.}
\end{frame}

\begin{frame}
\frametitle{Text Editors}
\begin{itemize}
    \item Many options:
    \begin{itemize}
        \item Notepad++
        \item Vim, Emacs
        \item Atom
        \item Sublime text
    \end{itemize}
    \item We will be creating and editing text files, hence the need for a
        text editor.
    \item The choice of editor is unimportant; what \emph{is} important is
        that you feel comfortable using yours.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Using Git on your own}

\begin{frame}
\frametitle{Using Git on your own}
\begin{itemize}
    \item Why?
    \item Get benefits of version control
    \item Get even more benefits when working with others; we'll discuss
        this in more detail later in the course
    \item Use Git on your local computer
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Starting a new repository from scratch}
\begin{itemize}
    \item mkdir something
    \item cd something
    \item git init  (also ls -la)
    \item git status
    \item create file
    \item git status (untracked)
    \item git add
    \item git status (staged)
    \item git commit
    \item git status (clean)
    \item git config user.name; git config user.email
    \item master is default branch
    \item (normally don't have to run git status all the time)
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Starting a new repository (conceptual steps)}
\begin{itemize}
    \item To create a repository, need to \ttt{init}ialise it
        \begin{itemize}
            \item git init
        \end{itemize}
    \item Repository is just a directory, with a .git directory
        \begin{itemize}
            \item ls -la
        \end{itemize}
    \item Things that go into a repository are just files
        \begin{itemize}
            \item touch file
        \end{itemize}
    \item To tell Git to track a file, need to \ttt{add} it
        \begin{itemize}
            \item git add
        \end{itemize}
    \item Tracked files and \emph{changes to tracked files} are put in
        the \emph{staging area}
        \begin{itemize}
            \item git status (see staged)
        \end{itemize}
    \item To record files and \emph{changes to files}, one \ttt{commit}s
        them to the repository
        \begin{itemize}
            \item git commit
        \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Exercise: Start a new repository}
\begin{itemize}
    \item Repeat the previous steps on your own computer
    \item Create a directory and change into it
    \item Initialise the repository
    \item Run git status to see the current repository state
    \item Create a file (untracked); see the repository state
    \item Add the file to the repository (track it); see the repository state
    \item Commit the file to the repository; see the repository state
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Minor Detour: Git Configuration}
\begin{itemize}
    \item Brief intro to git config
    \item Repo-local config
    \item Global config
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Getting Help}
\begin{itemize}
    \item man pages
    \item git help
    \item books
    \item online references
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Exercise: git help}
\begin{itemize}
    \item Use \code{git help} on \code{init}, \code{add}, \code{commit} and
        \code{config} commands
    \item Open and browse on \url{https://git-scm.org}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Parts of a local Git repository}
\begin{itemize}
    \item Working directory
    \item Staging area
    \item Repository
    \item Very important for understanding operations
    \item need image of wd, staging and repo
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Snapshots and diffs}
\begin{itemize}
    \item Photograph analogy
    \item Commits build on one another
    \item Working directory: checked out version of local repository
    \item Staging area: what will be committed next
    \item Repository: storage of snapshots
    \item Contrast with other systems, which store diffs between changes
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Basic workflow}
\begin{itemize}
    \item creation (mkdir, init, edit)
    \item saving snapshots of work (add, commit, return to edit step)
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Extending the sample project}
\begin{itemize}
    \item edit, add, commit
    \item seeing what we've done
    \begin{itemize}
        \item git log (--graph)
        \item git show
        \item git diff
    \end{itemize}
    \item deleting/renaming files
    \begin{itemize}
        \item git rm
        \item git mv
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Explan SHAs}
\begin{itemize}
    \item in context of diff, show, log, etc.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Exercise: extend the sample project further}
\begin{itemize}
    \item recommended steps \ldots
    \item practice git add/commit/rm/mv
    \item practice git log/show/diff
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Import existing project}
\begin{itemize}
    \item git init, git add, git commit
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Aliasing commands}
\begin{itemize}
    \item reduce typing, use alias
    \item handy aliases: st, di, ci, co
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Staging and unstaging files}
\begin{itemize}
    \item staging area in more depth
    \item unstage files one doesn't want to track
    \item git reset (just moves pointer/label)
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Exercise!}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Using Git with others}

\begin{frame}
\frametitle{Working with others}
\begin{itemize}
    \item a networked world
    \item version control becomes more interesting when one works with
        others
    \item author and committer can be different people (usually aren't)
    \item work more often with branches (very powerful feature)
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Add remote repos to model}
\begin{itemize}
    \item working directory
    \item staging area
    \item local repo
    \item remote repo(s)
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Cloning an existing repo}
\begin{itemize}
    \item git clone
    \item changes to git config --list
    \item explain meaning of origin
    \item master, origin/master, HEAD
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Exercise!}
\end{frame}

\begin{frame}
\frametitle{Dealing with conflicts}
\begin{itemize}
    \item can happen when working on same part of a file
    \item happens when working with others
    \item happens when working with branches and stashes (hence can also
        happen when one is working alone!)
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Exercise!}
\end{frame}

\begin{frame}
\frametitle{Branches}
\begin{itemize}
    \item what are they?
    \item why use them?
    \item localise work on a focussed topic
    \item don't interfere with main development on master
    \item allows devs to work on parts of projects independently
    \item allows for code reviews before merging
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{The default branch: master}

Discuss push/pull just from master?  Then have push/pull concept ready
for quick fix example below
\end{frame}

\begin{frame}
\frametitle{Branches}
\begin{itemize}
    \item git branch
    \item git branch -a
    \item git branch <branchname>
    \item git checkout <branchname>
    \item git checkout -b <branchname>
    \item naming branches -> clarity very helpful
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Simple branch}
\begin{center}
    \resizebox{!}{0.7\textheight}{
        \input{figures/simple_branch_tikz.tex}
    }
\end{center}
\end{frame}

\begin{frame}
\frametitle{Examples and exercises!}
\end{frame}

\begin{frame}
\frametitle{Merging branches}
\begin{itemize}
    \item merge changes on one branch into another
    \item git merge <branchname>
    \item fast-forward merge
    \item merge commits
    \item conflicts can occur (merge conflicts)
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Merging branches}
\begin{center}
    \resizebox{!}{0.7\textheight}{
        \input{figures/merge_simple_branch_tikz.tex}
    }
\end{center}
\end{frame}

\begin{frame}
\frametitle{Example: quick fix}
\begin{itemize}
    \item when working on a new feature (on a feature branch)
    \item bug found on main branch -> quick fix necessary
    \item commit changes on current branch
    \item checkout master
    \item checkout quick fix branch (git checkout -b <branchname>)
    \item make fix, test, commit
    \item merge into master, push
    \item return to work on feature branch
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Example: handling merge conflicts}
\begin{itemize}
    \item work on same area of code
    \item try to merge
    \item handle (resolve) conflict
    \item git add (to mark as resolved)
    \item git commit (as necessary)
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Cherry picking}
\begin{itemize}
    \item associated with merging
    \item only when some commits are wanted
    \item git cherry-pick <commit>
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Local and remote branches}
\end{frame}

\begin{frame}
\frametitle{Fetching from remotes}
\begin{itemize}
    \item git pull $\approx$ git fetch; git merge
    \item why fetch then merge?
    \item origin is writable but upstream isn't -> common OSS model
    \item define upstream
    \item changes are made on upstream
    \item fetch changes to local repo
    \item merge changes into local branch (e.g. master)
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Exercise!}
\end{frame}

\begin{frame}
\frametitle{Rewriting history}
\begin{itemize}
    \item unpublished (not yet pushed) changes can be rearranged
    \item reorder, edit, squash, reword, delete (split also possible,
        but more involved)
    \item the story on wants to tell about the development; not all
        commits need to be pushed
    \item allows one to polish the changes; improve quality
    \item linearise changes; published repo has clear, linear history
        (see e.g. Ovid's slide about git histories)
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Interactive rebase}
\begin{itemize}
    \item git rebase -i
    \item very handy to clean up history before pushing
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Stashing changes}
\begin{itemize}
    \item why use this?
    \item what is this?
    \item handy feature for interrupted work
    \item e.g. quick fix example
    \item git stash
    \item git stash show -p
    \item git stash pop (conflicts possible)
    \item git stash drop
    \item git stash drop/show {n}
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Using a version control system service}

\begin{frame}
    \frametitle{Online VCS services}
    \begin{itemize}
        \item GitHub
        \item GitLab
        \item BitBucket
    \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

https://stackoverflow.com/questions/953481/find-and-restore-a-deleted-file-in-a-git-repository

\begin{verbatim}
git checkout $(git rev-list -n 1 HEAD -- "$file")^ -- "$file"
\end{verbatim}

the file is then shown as a new file in the repo.  One can use `git diff
--cached` to see its contents.

\begin{verbatim}
git rev-list -n 1 HEAD -- "$file"
\end{verbatim}

finds the last commit affecting the file.  Since this is the last commit
affecting the file, it must be the commit where the file was deleted.  Hence
the commit directly preceding this one will be the last commit where the
file was still intact (the parent commit).  The parent commit of a given
commit is specified with the caret \ttt{\^} character, hence we check out
the parent commit of the deletion commit specifying just to operate on the
given file.



Recover a lost/deleted commit

https://stackoverflow.com/questions/10099258/how-can-i-recover-a-lost-commit-in-git

Git doesn't immediately delete a commit that is no longer attached to any
previous commit, it performs such cleanup operations on a periodic basis.
Hence, if one wants information about a commit that is no longer available
via \ttt{tig} or \ttt{git log} however hasn't yet been garbage collected,
one can still access this information by using \ttt{git reflog}.  This shows
a log of all operations on references and hence the SHA hash will still be
avaiable for the missing commit.  Using this hash reference, one can recover
the commit, or if one only wants the commit message (say), then a simple
\ttt{git log <sha-hash>} will return the required information.



Splitting commits

https://stackoverflow.com/questions/6217156/break-a-previous-commit-into-multiple-commits



\end{document}

% vim: expandtab shiftwidth=4:
